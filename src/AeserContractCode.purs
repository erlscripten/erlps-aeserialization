module Aeser.Contract.Code(erlps__deserialize__1,
                           erlps__serialize__1, erlps__serialize__2) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__serialize__1 :: ErlangFun
erlps__serialize__1 [codemap_0] =
  let arg_2 = toErl 3
  in erlps__serialize__2 [codemap_0, arg_2]
erlps__serialize__1 [arg_3] = EXC.function_clause unit
erlps__serialize__1 args =
  EXC.badarity (ErlangFun 1 erlps__serialize__1) args

erlps__serialize__2 :: ErlangFun
erlps__serialize__2 [codemap_3@(ErlangMap map_0),
                     sophiacontractversion_4]
  | (DM.Just typeinfo_2) <-
      (Map.lookup (ErlangAtom "type_info") map_0)
  , (DM.Just bytecode_1) <-
      (Map.lookup (ErlangAtom "byte_code") map_0) =
  let   
    sourcehash_15 =
      case codemap_3 of
        (ErlangMap map_6) | (DM.Just shash_7) <-
                              (Map.lookup (ErlangAtom "source_hash") map_6) ->
          shash_7
        (ErlangMap map_8) | (DM.Just srcstr_9) <-
                              (Map.lookup (ErlangAtom "contract_source")
                                 map_8) ->
          let    arg_10 = toErl 32
          in let arg_11 = BIF.erlang__list_to_binary__1 [srcstr_9]
          in let
            matchExpr_14 =
              BIF.do_remote_fun_call "Enacl" "erlps__generichash__2"
                [arg_10, arg_11]
          in
            case matchExpr_14 of
              (ErlangTuple [(ErlangAtom "ok"), shash_13]) -> shash_13
              _ -> EXC.badmatch matchExpr_14
        something_else -> EXC.case_clause something_else
  in let
    arg_18 =
      ErlangBinary (BIN.fromInts (toErl "unknown") (toErl 8) 1 BIN.Big)
  in let
    version_19 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [ErlangAtom "compiler_version", codemap_3, arg_18]
  in let
    binversion_21 =
      case ErlangAtom "true" of
        _ | isEInt version_19 ->
          BIF.erlang__integer_to_binary__1 [version_19]
        _ | isEBinary version_19 -> version_19
        _ -> EXC.if_clause unit
  in let
    payable_25 =
      BIF.do_remote_fun_call "Maps" "erlps__get__3"
        [ErlangAtom "payable", codemap_3, ErlangAtom "true"]
  in let
    head_27 = ErlangTuple [ErlangAtom "source_hash", sourcehash_15]
  in let head_31 = ErlangTuple [ErlangAtom "type_info", typeinfo_2]
  in let head_35 = ErlangTuple [ErlangAtom "byte_code", bytecode_1]
  in let rop_43 = toErl 1
  in let
    cond_41 =
      BIF.erlang__op_greater [sophiacontractversion_4, rop_43]
  in let
    lop_40 =
      case cond_41 of
        (ErlangAtom "true") ->
          let
            lcRet_44 =
              ErlangTuple [ErlangAtom "compiler_version", binversion_21]
          in ErlangCons lcRet_44 ErlangEmptyList
        _ -> ErlangEmptyList
  in let rop_50 = toErl 2
  in let
    cond_48 =
      BIF.erlang__op_greater [sophiacontractversion_4, rop_50]
  in let
    rop_47 =
      case cond_48 of
        (ErlangAtom "true") ->
          let lcRet_51 = ErlangTuple [ErlangAtom "payable", payable_25]
          in ErlangCons lcRet_51 ErlangEmptyList
        _ -> ErlangEmptyList
  in let rop_39 = BIF.erlang__op_append [lop_40, rop_47]
  in let
    fields_54 =
      BIF.erlang__op_append
        [ErlangCons head_27
           (ErlangCons head_31 (ErlangCons head_35 ErlangEmptyList)),
         rop_39]
  in let
    arg_57 =
      erlps__serialization_template__1 [sophiacontractversion_4]
  in
    BIF.do_remote_fun_call "Aeser.Chain.Objects"
      "erlps__serialize__4"
      [ErlangAtom "compiler_sophia", sophiacontractversion_4, arg_57,
       fields_54]
erlps__serialize__2 [arg_60, arg_61] = EXC.function_clause unit
erlps__serialize__2 args =
  EXC.badarity (ErlangFun 2 erlps__serialize__2) args

erlps__deserialize__1 :: ErlangFun
erlps__deserialize__1 [binary_0] =
  let
    case_1 =
      BIF.do_remote_fun_call "Aeser.Chain.Objects"
        "erlps__deserialize_type_and_vsn__1" [binary_0]
  in
    case case_1 of
      (ErlangTuple [type_3@(ErlangAtom "compiler_sophia"),
                    vsn_5@(ErlangInt num_4), _rest_6]) | (ErlangInt num_4) ==
                                                           (toErl 1) ->
        let    template_8 = erlps__serialization_template__1 [vsn_5]
        in let
          matchExpr_16 =
            BIF.do_remote_fun_call "Aeser.Chain.Objects"
              "erlps__deserialize__4" [type_3, vsn_5, template_8, binary_0]
        in
          case matchExpr_16 of
            (ErlangCons (ErlangTuple [(ErlangAtom "source_hash"),
                                      hash_13]) (ErlangCons (ErlangTuple [(ErlangAtom "type_info"),
                                                                          typeinfo_14]) (ErlangCons (ErlangTuple [(ErlangAtom "byte_code"),
                                                                                                                  bytecode_15]) (ErlangEmptyList)))) ->
              ErlangMap
                (Map.fromFoldable
                   [DT.Tuple (ErlangAtom "source_hash") hash_13,
                    DT.Tuple (ErlangAtom "type_info") typeinfo_14,
                    DT.Tuple (ErlangAtom "byte_code") bytecode_15,
                    DT.Tuple (ErlangAtom "contract_vsn") vsn_5,
                    DT.Tuple (ErlangAtom "payable") (ErlangAtom "true")])
            _ -> EXC.badmatch matchExpr_16
      (ErlangTuple [type_27@(ErlangAtom "compiler_sophia"),
                    vsn_29@(ErlangInt num_28), _rest_30]) | (ErlangInt
                                                               num_28) ==
                                                              (toErl 2) ->
        let    template_32 = erlps__serialization_template__1 [vsn_29]
        in let
          matchExpr_41 =
            BIF.do_remote_fun_call "Aeser.Chain.Objects"
              "erlps__deserialize__4" [type_27, vsn_29, template_32, binary_0]
        in
          case matchExpr_41 of
            (ErlangCons (ErlangTuple [(ErlangAtom "source_hash"),
                                      hash_37]) (ErlangCons (ErlangTuple [(ErlangAtom "type_info"),
                                                                          typeinfo_38]) (ErlangCons (ErlangTuple [(ErlangAtom "byte_code"),
                                                                                                                  bytecode_39]) (ErlangCons (ErlangTuple [(ErlangAtom "compiler_version"),
                                                                                                                                                          compilerversion_40]) (ErlangEmptyList))))) ->
              ErlangMap
                (Map.fromFoldable
                   [DT.Tuple (ErlangAtom "source_hash") hash_37,
                    DT.Tuple (ErlangAtom "type_info") typeinfo_38,
                    DT.Tuple (ErlangAtom "byte_code") bytecode_39,
                    DT.Tuple (ErlangAtom "compiler_version") compilerversion_40,
                    DT.Tuple (ErlangAtom "contract_vsn") vsn_29,
                    DT.Tuple (ErlangAtom "payable") (ErlangAtom "true")])
            _ -> EXC.badmatch matchExpr_41
      (ErlangTuple [type_54@(ErlangAtom "compiler_sophia"),
                    vsn_56@(ErlangInt num_55), _rest_57]) | (ErlangInt
                                                               num_55) ==
                                                              (toErl 3) ->
        let    template_59 = erlps__serialization_template__1 [vsn_56]
        in let
          matchExpr_69 =
            BIF.do_remote_fun_call "Aeser.Chain.Objects"
              "erlps__deserialize__4" [type_54, vsn_56, template_59, binary_0]
        in
          case matchExpr_69 of
            (ErlangCons (ErlangTuple [(ErlangAtom "source_hash"),
                                      hash_64]) (ErlangCons (ErlangTuple [(ErlangAtom "type_info"),
                                                                          typeinfo_65]) (ErlangCons (ErlangTuple [(ErlangAtom "byte_code"),
                                                                                                                  bytecode_66]) (ErlangCons (ErlangTuple [(ErlangAtom "compiler_version"),
                                                                                                                                                          compilerversion_67]) (ErlangCons (ErlangTuple [(ErlangAtom "payable"),
                                                                                                                                                                                                         payable_68]) (ErlangEmptyList)))))) ->
              ErlangMap
                (Map.fromFoldable
                   [DT.Tuple (ErlangAtom "source_hash") hash_64,
                    DT.Tuple (ErlangAtom "type_info") typeinfo_65,
                    DT.Tuple (ErlangAtom "byte_code") bytecode_66,
                    DT.Tuple (ErlangAtom "compiler_version") compilerversion_67,
                    DT.Tuple (ErlangAtom "contract_vsn") vsn_56,
                    DT.Tuple (ErlangAtom "payable") payable_68])
            _ -> EXC.badmatch matchExpr_69
      other_82 ->
        let
          arg_83 = ErlangTuple [ErlangAtom "illegal_code_object", other_82]
        in BIF.erlang__error__1 [arg_83]
erlps__deserialize__1 [arg_86] = EXC.function_clause unit
erlps__deserialize__1 args =
  EXC.badarity (ErlangFun 1 erlps__deserialize__1) args

erlps__serialization_template__1 :: ErlangFun
erlps__serialization_template__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 1) =
  let   
    head_1 =
      ErlangTuple [ErlangAtom "source_hash", ErlangAtom "binary"]
  in let
    head_8 =
      ErlangTuple
        [ErlangAtom "binary", ErlangAtom "binary", ErlangAtom "binary",
         ErlangAtom "binary"]
  in let
    head_5 =
      ErlangTuple
        [ErlangAtom "type_info", ErlangCons head_8 ErlangEmptyList]
  in let
    head_15 =
      ErlangTuple [ErlangAtom "byte_code", ErlangAtom "binary"]
  in
    ErlangCons head_1
      (ErlangCons head_5 (ErlangCons head_15 ErlangEmptyList))
erlps__serialization_template__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 2) =
  let   
    head_1 =
      ErlangTuple [ErlangAtom "source_hash", ErlangAtom "binary"]
  in let
    head_8 =
      ErlangTuple
        [ErlangAtom "binary", ErlangAtom "binary", ErlangAtom "binary",
         ErlangAtom "binary"]
  in let
    head_5 =
      ErlangTuple
        [ErlangAtom "type_info", ErlangCons head_8 ErlangEmptyList]
  in let
    head_15 =
      ErlangTuple [ErlangAtom "byte_code", ErlangAtom "binary"]
  in let
    head_19 =
      ErlangTuple [ErlangAtom "compiler_version", ErlangAtom "binary"]
  in
    ErlangCons head_1
      (ErlangCons head_5
         (ErlangCons head_15 (ErlangCons head_19 ErlangEmptyList)))
erlps__serialization_template__1 [(ErlangInt num_0)]
  | (ErlangInt num_0) == (toErl 3) =
  let   
    head_1 =
      ErlangTuple [ErlangAtom "source_hash", ErlangAtom "binary"]
  in let
    head_8 =
      ErlangTuple
        [ErlangAtom "binary", ErlangAtom "binary", ErlangAtom "bool",
         ErlangAtom "binary", ErlangAtom "binary"]
  in let
    head_5 =
      ErlangTuple
        [ErlangAtom "type_info", ErlangCons head_8 ErlangEmptyList]
  in let
    head_16 =
      ErlangTuple [ErlangAtom "byte_code", ErlangAtom "binary"]
  in let
    head_20 =
      ErlangTuple [ErlangAtom "compiler_version", ErlangAtom "binary"]
  in let
    head_24 = ErlangTuple [ErlangAtom "payable", ErlangAtom "bool"]
  in
    ErlangCons head_1
      (ErlangCons head_5
         (ErlangCons head_16
            (ErlangCons head_20 (ErlangCons head_24 ErlangEmptyList))))
erlps__serialization_template__1 [arg_28] =
  EXC.function_clause unit
erlps__serialization_template__1 args =
  EXC.badarity (ErlangFun 1 erlps__serialization_template__1) args