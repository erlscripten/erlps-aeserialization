module Aeser.Contract.Code.Tests(erlps__test__0,
                                 erlps__vsn_1_test__0, erlps__vsn_2_test__0,
                                 erlps__vsn_3_test__0) where
{-
This file has been autogenerated
DO NOT EDIT - Your changes WILL be overwritten
Use this code at your own risk - the authors are just a mischievous raccoon and a haskell devote
Erlscripten v0.2.0
-}

import Prelude
import Data.BigInt as DBI
import Data.Array as DA
import Data.Maybe as DM
import Data.Map as Map
import Data.Tuple as DT
import Erlang.Builtins as BIF
import Erlang.Binary as BIN
import Erlang.Helpers
import Erlang.Exception as EXC
import Erlang.Type
import Partial.Unsafe (unsafePartial)


erlps__vsn_1_test__0 :: ErlangFun
erlps__vsn_1_test__0 [] =
  let   
    val_5 =
      ErlangBinary
        (BIN.fromInts (toErl "DUMMY CODE") (toErl 8) 1 BIN.Big)
  in let tup_el_8 = ErlangBinary (BIN.concat [])
  in let tup_el_9 = ErlangBinary (BIN.concat [])
  in let tup_el_10 = ErlangBinary (BIN.concat [])
  in let tup_el_11 = ErlangBinary (BIN.concat [])
  in let
    head_7 = ErlangTuple [tup_el_8, tup_el_9, tup_el_10, tup_el_11]
  in let val_13 = toErl "contract Foo = ..."
  in let
    arg_1 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "byte_code") val_5,
            DT.Tuple (ErlangAtom "type_info")
              (ErlangCons head_7 ErlangEmptyList),
            DT.Tuple (ErlangAtom "contract_source") val_13])
  in let arg_14 = toErl 1
  in let
    arg_0 =
      BIF.do_remote_fun_call "Aeser.Contract.Code"
        "erlps__serialize__2" [arg_1, arg_14]
  in
    BIF.do_remote_fun_call "Aeser.Contract.Code"
      "erlps__deserialize__1" [arg_0]
erlps__vsn_1_test__0 args =
  EXC.badarity (ErlangFun 0 erlps__vsn_1_test__0) args

erlps__vsn_2_test__0 :: ErlangFun
erlps__vsn_2_test__0 [] =
  let   
    val_6 =
      ErlangBinary
        (BIN.fromInts (toErl "DUMMY CODE") (toErl 8) 1 BIN.Big)
  in let tup_el_9 = ErlangBinary (BIN.concat [])
  in let tup_el_10 = ErlangBinary (BIN.concat [])
  in let tup_el_11 = ErlangBinary (BIN.concat [])
  in let tup_el_12 = ErlangBinary (BIN.concat [])
  in let
    head_8 = ErlangTuple [tup_el_9, tup_el_10, tup_el_11, tup_el_12]
  in let
    val_14 =
      ErlangBinary (BIN.fromInts (toErl "3.1.4") (toErl 8) 1 BIN.Big)
  in let bin_el_16 = toErl 1
  in let bin_el_17 = toErl 2
  in let bin_el_18 = toErl 3
  in let bin_el_19 = toErl 4
  in let
    val_15 =
      ErlangBinary
        (BIN.concat
           [BIN.fromInt bin_el_16 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_17 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_18 (toErl 8) 1 BIN.Big,
            BIN.fromInt bin_el_19 (toErl 8) 1 BIN.Big])
  in let
    arg_1 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "byte_code") val_6,
            DT.Tuple (ErlangAtom "type_info")
              (ErlangCons head_8 ErlangEmptyList),
            DT.Tuple (ErlangAtom "compiler_version") val_14,
            DT.Tuple (ErlangAtom "source_hash") val_15])
  in let arg_20 = toErl 2
  in let
    arg_0 =
      BIF.do_remote_fun_call "Aeser.Contract.Code"
        "erlps__serialize__2" [arg_1, arg_20]
  in
    BIF.do_remote_fun_call "Aeser.Contract.Code"
      "erlps__deserialize__1" [arg_0]
erlps__vsn_2_test__0 args =
  EXC.badarity (ErlangFun 0 erlps__vsn_2_test__0) args

erlps__vsn_3_test__0 :: ErlangFun
erlps__vsn_3_test__0 [] =
  let   
    val_7 =
      ErlangBinary
        (BIN.fromInts (toErl "DUMMY CODE") (toErl 8) 1 BIN.Big)
  in let tup_el_10 = ErlangBinary (BIN.concat [])
  in let tup_el_11 = ErlangBinary (BIN.concat [])
  in let tup_el_13 = ErlangBinary (BIN.concat [])
  in let tup_el_14 = ErlangBinary (BIN.concat [])
  in let
    head_9 =
      ErlangTuple
        [tup_el_10, tup_el_11, ErlangAtom "false", tup_el_13, tup_el_14]
  in let
    val_16 =
      ErlangBinary (BIN.fromInts (toErl "3.1.4") (toErl 8) 1 BIN.Big)
  in let val_17 = toErl "contract Foo = ..."
  in let
    arg_1 =
      ErlangMap
        (Map.fromFoldable
           [DT.Tuple (ErlangAtom "byte_code") val_7,
            DT.Tuple (ErlangAtom "type_info")
              (ErlangCons head_9 ErlangEmptyList),
            DT.Tuple (ErlangAtom "compiler_version") val_16,
            DT.Tuple (ErlangAtom "contract_source") val_17,
            DT.Tuple (ErlangAtom "payable") (ErlangAtom "true")])
  in let arg_19 = toErl 3
  in let
    arg_0 =
      BIF.do_remote_fun_call "Aeser.Contract.Code"
        "erlps__serialize__2" [arg_1, arg_19]
  in
    BIF.do_remote_fun_call "Aeser.Contract.Code"
      "erlps__deserialize__1" [arg_0]
erlps__vsn_3_test__0 args =
  EXC.badarity (ErlangFun 0 erlps__vsn_3_test__0) args

erlps__test__0 :: ErlangFun
erlps__test__0 [] =
  BIF.do_remote_fun_call "Eunit" "erlps__test__1"
    [ErlangAtom "aeser_contract_code_tests"]
erlps__test__0 args =
  EXC.badarity (ErlangFun 0 erlps__test__0) args